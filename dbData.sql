--
-- PostgreSQL database dump
--

-- Dumped from database version 14.4
-- Dumped by pg_dump version 14.4

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- Data for Name: User; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public."User" (id, name, "lastName", username, hash, salt, "createdAt", role) FROM stdin;
14ee2e28-d7cb-4a8b-85d0-fa731615e6d4	Pietro	Ferrara	pietro.ferrara@gmail.com	e1d3f17efcc4053f1ec8b27a5afc20c21ab47dbcb37e9dcb1483a51935ec8f89b85b2fec57c530849ed2fcfb3cb2a8f9d3083bf60748d3159dc3c159bd00f6b5	c645e31a26c3b3fb0143bd6f9fef2593	1669104841557	PROF
fb28399a-dcce-47f0-82cd-fdac5c5d9752	Francesco	Vinci	francesco98vinci@gmail.com	cab29a1dfa6bdbe1a2a9c94906b74f7301f548aca47dffbf9e24d4ba7ad7e80265d767c78f085b59c1855cb6873b59512c1e57f016206a4daa787a3d729c0bed	94c377d99043230a258b718e22236e5d	1669104941721	USER
50d88e10-20eb-46d6-8467-fa9a790941a4	Michele	Bugliesi	michele.bugliesi@gmail.com	5941274d59cc8ab73804fc8bd9a60df3c6e569760dedff55aca0b3e6430da03dda55683c59cb82ae6f5f8eec70c8c592a8447406782f6e961601dd35dfbb460b	9c0e9c14caa0a43f4fff0d0a6bb8634f	1669104863979	PROF
7c2387b5-06d5-4342-a12e-7808bd821f2c	admin	admin	admin@admin.it	56eb403c9636cf7213fdf45db63b3dcbb62db618cfa026f01be6fa4a3f4072dc05af4756d443fb96d21d5d2e328da95eacc0d1cb7587b5b00a1cc3940a481d6e	fdd527fc91ba6561fedb21e374e211c9	1669104784199	ADMIN
c811bbcd-fbaa-49b1-8ab4-7f7430d80758	Antonio	Cimino	antonio.cimino@gmail.com	c461c674ebe14814076b4af60ff754b0223dc6acc79a65ecc08c4a75971231aed496c79b287787b74747db00408b93057b94ad322e5a1af39e791c0f2f8f4943	11b793e9075077cf34cfc1c04a92b202	1669839291701	USER
52af8238-3845-4453-93fe-ea9958a449ae	Filippo	Bedon	filippo.bedon@gmail.com	02fae06081e6c639d9892fae7036b573fb8c250b8ca1e98222f86909c5ad2832e9bddda5e609792320bd811d15901020c0c4bbfdc531355831f865451a878767	71abf00150f52f3bd01d02c3150e6812	1669839317178	USER
87061c70-3a40-48bf-a96d-f803fafb0727	Marco	Tubia	marco.tubia@gmail.com	9c38dee81927306996a3fa9815fdb9609c6d7484ace45b3df59e23b1d658bb2547fec81ff557e75e3d3feac25812f9026076d3aab468e4e79ef72bc16c678d72	a7ce6321016fbeb3cb220f4affadecdc	1669839339241	USER
37c69128-0f9b-4232-942b-74a8b728355d	Davide	Bresaola	davide.bresaola@gmail.com	e38e178db3e420941e75807529c72bb6a942ea3ea583b3c9b4d9550e6f484b7ff512005849b17ffc967ef944f8a50f7cc2e9ca0db1b75a02c61a04397aaeca70	24d200565272e24b4f7eddd3c8cf2a06	1669839365710	USER
\.


--
-- Data for Name: Course; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public."Course" (id, name, "userId", "academicYear") FROM stdin;
f5347272-1a3e-43d0-91f1-762d5944c6fb	Programmazione a Oggetti	14ee2e28-d7cb-4a8b-85d0-fa731615e6d4	2022/2023
def826ea-4868-4a7c-8bce-f7df1d5e3ae8	Advanced Programming Languages	50d88e10-20eb-46d6-8467-fa9a790941a4	2022/2023
ae1042cf-7d55-4157-81c6-2690d839609b	Introduzione alla Programmazione	14ee2e28-d7cb-4a8b-85d0-fa731615e6d4	2022/2023
\.


--
-- Data for Name: Registration; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public."Registration" (id, "userId", "courseId", "createdAt") FROM stdin;
5d7a4693-75f6-47b0-83f0-e3deccfe94f6	fb28399a-dcce-47f0-82cd-fdac5c5d9752	f5347272-1a3e-43d0-91f1-762d5944c6fb	1669104953444
084b4db5-c27c-474d-98ea-5d9cb4e32ee1	fb28399a-dcce-47f0-82cd-fdac5c5d9752	def826ea-4868-4a7c-8bce-f7df1d5e3ae8	1669104958136
4ddfc94f-7a43-4e60-9ead-2555463d4076	c811bbcd-fbaa-49b1-8ab4-7f7430d80758	f5347272-1a3e-43d0-91f1-762d5944c6fb	1669839381899
94811c75-0bb2-4786-b6cc-b0514f075fd5	52af8238-3845-4453-93fe-ea9958a449ae	f5347272-1a3e-43d0-91f1-762d5944c6fb	1669839405078
552d8eb9-c684-4e40-9d2c-f9947b4d30b2	87061c70-3a40-48bf-a96d-f803fafb0727	f5347272-1a3e-43d0-91f1-762d5944c6fb	1669839424275
413fedd4-6c80-4cd1-9452-18dc5a899d54	37c69128-0f9b-4232-942b-74a8b728355d	f5347272-1a3e-43d0-91f1-762d5944c6fb	1669839444475
fd36de41-8f16-4e0f-b577-15474280d634	fb28399a-dcce-47f0-82cd-fdac5c5d9752	ae1042cf-7d55-4157-81c6-2690d839609b	1669839557398
02510823-67fa-430a-a24e-9904c037fd4e	c811bbcd-fbaa-49b1-8ab4-7f7430d80758	ae1042cf-7d55-4157-81c6-2690d839609b	1669839572793
\.


--
-- Data for Name: Task; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public."Task" (id, "courseId", title, assignment, deadline, "testCase", hint, solution, "createdAt", language, placeholder) FROM stdin;
3f565f7c-6115-43a4-a68a-6f42a7c62c62	f5347272-1a3e-43d0-91f1-762d5944c6fb	Task 0: Longest Substring Without Repeating Characters	Given a string  `s`, find the length of the  **longest** **substring** without repeating characters.\n\n**Example 1:**\n\n```js\nInput: s = "abcabcbb"\nOutput: 3\nExplanation: The answer is "abc", with the length of 3.\n```\n\n**Example 2:**\n```js\nInput: s = "bbbbb"\nOutput: 1\nExplanation: The answer is "b", with the length of 1.\n```\n**Example 3:**\n```js\nInput: s = "pwwkew"\nOutput: 3\nExplanation: The answer is "wke", with the length of 3.\nNotice that the answer must be a substring, "pwke" is a subsequence and not a substring.\n```\n**Constraints:**\n\n-   `0 <= s.length <= 5 * 104`\n-   `s`  consists of English letters, digits, symbols and spaces.	1669666660000	s = "abcabcbb"	# Hint\n\n### Approach: Brute Force\n\n#### Intuition\n\nCheck all the substring one by one to see if it has no duplicate character.\n\n#### Algorithm\n\nSuppose we have a function  `boolean allUnique(String substring)`  which will return true if the characters in the substring are all unique, otherwise false. We can iterate through all the possible substrings of the given string  `s`  and call the function  `allUnique`. If it turns out to be true, then we update our answer of the maximum length of substring without duplicate characters.\n\nNow let's fill the missing parts:\n\n1.  To enumerate all substrings of a given string, we enumerate the start and end indices of them. Suppose the start and end indices are  `i`  and  `j`, respectively. Then we have  $0\\leq i<j \\leq n$  (here end index  jjj  is exclusive by convention). Thus, using two nested loops with `i` from `0` to `n−1` and  `j`  from `i+1` to `n`, we can enumerate all the substrings of  `s`.\n    \n2.  To check if one string has duplicate characters, we can use a set. We iterate through all the characters in the string and put them into the  `set`  one by one. Before putting one character, we check if the set already contains it. If so, we return  `false`. After the loop, we return  `true`.\n\n\n#### Complexity Analysis\n\n-   Time complexity :  $O(n^3)$.\n    \n    To verify if characters within index range $[i,j)$ are all unique, we need to scan all of them. Thus, it costs $O(j−i)$ time.\n    \n    For a given  `i`, the sum of time costed by each  $j \\in [i+1,n]$ is\n    \n    $$\\sum_{i+1}^{n}O(j - i)$$\n    \n    Thus, the sum of all the time consumption is:\n    \n    $$O\\left(\\sum_{i = 0}^{n - 1}\\left(\\sum_{j = i + 1}^{n}(j - i)\\right)\\right) = O\\left(\\sum_{i = 0}^{n - 1}\\frac{(1 + n - i)(n - i)}{2}\\right) = O(n^3)$$\n    \n-   Space complexity :  $O(min(n,m))$. We need $O(k)$ space for checking a substring has no duplicate characters, where $k$ is the size of the  `Set`. The size of the Set is upper bounded by the size of the string  nnn  and the size of the charset/alphabet $m$.	Output: 3	1669836309578	javascript	var lengthOfLongestSubstring = function(s) {\r\n    var i=0;\r\n    var MAX=0;\r\n    var temp = new Map();\r\n   \r\n    while(i < s.length){\r\n        \r\n        if(!temp.has(s[i])){\r\n            temp.set(s[i], i);\r\n            var size = temp.size;\r\n            if(size > MAX){\r\n                \r\n                MAX = size;\r\n            }\r\n            i++;\r\n        }else{\r\n            i = temp.get(s[i]) + 1;\r\n            temp = new Map();\r\n        }\r\n    }\r\n    return MAX;\r\n};\r\n\r\n\r\nconsole.log(lengthOfLongestSubstring("abcabcbb"));
774664e3-699b-4736-b7de-752a84d4e149	f5347272-1a3e-43d0-91f1-762d5944c6fb	Task 3: Two Sum	Given an array of integers  `nums` and an integer  `target`, return  _indices of the two numbers such that they add up to  `target`_.\n\nYou may assume that each input would have  **_exactly_  one solution**, and you may not use the  _same_  element twice.\n\nYou can return the answer in any order.\n\n**Example 1:**\n```js\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation:** Because nums[0] + nums[1] == 9, we return [0, 1].\n```\n\n**Example 2:**\n\n```js\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n```\n\n**Example 3:**\n\n```js\nInput: nums = [3,3], target = 6\nOutput: [0,1]\n```\n\n**Constraints:**\n\n-   `2 <= nums.length <= 10^4`\n-   `-10^9 <= nums[i] <= 10^9`\n-   `-10^9 <= target <= 10^9`\n-   **Only one valid answer exists.**	1677615460000	nums = [2,7,11,15]\ntarget = 9	# Hint\n\n#### Approach 1: Brute Force\n\n**Algorithm**\n\nThe brute force approach is simple. Loop through each element  xxx  and find if there is another value that equals to  $target−x$.\n\n**Implementation**\nIn Java\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}\n```\n\n**Complexity Analysis**\n\n-   Time complexity: $O(n^2)$. For each element, we try to find its complement by looping through the rest of the array which takes $O(n)$ time. Therefore, the time complexity is $O(n^2)$.\n    \n-   Space complexity: $O(1)$. The space required does not depend on the size of the input array, so only constant space is used.\n    \n----------\n\n#### Approach 2: Two-pass Hash Table\n\n**Intuition**\n\nTo improve our runtime complexity, we need a more efficient way to check if the complement exists in the array. If the complement exists, we need to get its index. What is the best way to maintain a mapping of each element in the array to its index? A hash table.\n\nWe can reduce the lookup time from $O(n)$ to $O(1)$ by trading space for speed. A hash table is well suited for this purpose because it supports fast lookup in  _near_  constant time. I say "near" because if a collision occurred, a lookup could degenerate to $O(n)$ time. However, lookup in a hash table should be amortized $O(1)$ time as long as the hash function was chosen carefully.\n\n**Algorithm**\n\nA simple implementation uses two iterations. In the first iteration, we add each element's value as a key and its index as a value to the hash table. Then, in the second iteration, we check if each element's complement ($target−nums[i]$) exists in the hash table. If it does exist, we return current element's index and its complement's index. Beware that the complement must not be $nums[i]$ itself!\n\n**Implementation**\nIn Java\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            map.put(nums[i], i);\n        }\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement) && map.get(complement) != i) {\n                return new int[] { i, map.get(complement) };\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}\n```\n\n**Complexity Analysis**\n\n-   Time complexity:  $O(n)$. We traverse the list containing  nnn  elements exactly twice. Since the hash table reduces the lookup time to  O(1)O(1)O(1), the overall time complexity is $O(n)$.\n    \n-   Space complexity: $O(n)$. The extra space required depends on the number of items stored in the hash table, which stores exactly $n$ elements.\n    \n----------\n\n#### Approach 3: One-pass Hash Table\n\n**Algorithm**\n\nIt turns out we can do it in one-pass. While we are iterating and inserting elements into the hash table, we also look back to check if current element's complement already exists in the hash table. If it exists, we have found a solution and return the indices immediately.\n\n**Implementation**\nIn Java\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}\n```\n\n**Complexity Analysis**\n\n-   Time complexity: $O(n)$. We traverse the list containing  nnn  elements only once. Each lookup in the table costs only $O(1)$ time.\n    \n-   Space complexity: $O(n)$. The extra space required depends on the number of items stored in the hash table, which stores at most  nnn  elements.	Output: [0,1]	1669835656007	c	#include <stdio.h>\r\n\r\nint* twoSum(int* nums, int numsSize, int target, int* returnSize){\r\n    int *temp;\r\n    temp = (int *) malloc(sizeof(int) * 2);\r\n    for(int i=0; i<numsSize; i++){\r\n        for(int j=i+1; j<numsSize; j++){\r\n            if(nums[i]+nums[j] == target){\r\n                temp[0] = i;\r\n                temp[1] = j;\r\n                \r\n            }\r\n        }\r\n    }\r\n    *returnSize = 2;\r\n    return temp;\r\n    \r\n}\r\n\r\nint main(){\r\n    \r\n}\r\n\r\n
9627e7e4-921d-496c-9b95-286771ceff84	f5347272-1a3e-43d0-91f1-762d5944c6fb	Task 2: Median of Two Sorted Arrays	Given two sorted arrays  `nums1`  and  `nums2`  of size  `m`  and  `n`  respectively, return  **the median**  of the two sorted arrays.\n\nThe overall run time complexity should be  `O(log (m+n))`.\n\n**Example 1:**\n```js\nInput: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.\n```\n\n**Example 2:**\n```js\nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n```\n\n**Constraints:**\n\n-   `nums1.length == m`\n-   `nums2.length == n`\n-   `0 <= m <= 1000`\n-   `0 <= n <= 1000`\n-   `1 <= m + n <= 2000`\n-  $-10^6$ `<= nums1[i], nums2[i] <= ` $10^6$	1677615460000	nums1 = [1,3]\nnums2 = [2]	**step1**: merge the given arrays.\n\n**step2**: sort the new created array from small to big.\n\n**step3**: judge odd or even of n1 + n2\n\n**step4**: find median.\n\n**Note**: the two arrays don't even have to be sorted.	2.00000	1669835078452	c	#include <stdio.h>\r\n\r\ndouble findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size){\r\n    \r\n    int i=0, j=0, k=0;\r\n    int nums3Size = nums1Size+nums2Size;\r\n    int nums3[nums3Size];\r\n    \r\n    while(i<nums1Size && j<nums2Size){\r\n        if(nums1[i] < nums2[j]){\r\n            nums3[k] = nums1[i];\r\n            i++;\r\n            k++;\r\n        }else if(nums1[i] > nums2[j]){\r\n            nums3[k] = nums2[j];\r\n            j++;\r\n            k++;\r\n        } else {\r\n            nums3[k] = nums2[j];\r\n            j++;\r\n            k++;\r\n        } \r\n    }\r\n    \r\n    while(j<nums2Size){\r\n        nums3[k] = nums2[j];\r\n        j++;\r\n        k++;\r\n    }\r\n    \r\n    while(i<nums1Size){\r\n        nums3[k] = nums1[i];\r\n        i++;\r\n        k++;\r\n    }\r\n        \r\n    if(nums3Size%2 == 0){\r\n        int med1 = nums3[nums3Size/2];\r\n        int med2 = nums3[(nums3Size/2)-1];\r\n        return ((double)(med1+med2)/2);\r\n    }else {\r\n        return (double)(nums3[nums3Size/2]);\r\n    }\r\n}\r\n\r\nint main(){\r\n    \r\n}\r\n\r\n
576cc927-27a4-4f4f-a3ce-1386ccee5790	ae1042cf-7d55-4157-81c6-2690d839609b	Task 1: Integer to Roman	Roman numerals are represented by seven different symbols: `I`,  `V`,  `X`,  `L`,  `C`,  `D`  and  `M`.\n\n```\nSymbol       Value\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n```\n\nFor example, `2`  is written as  `II` in Roman numeral, just two one's added together.  `12`  is written as `XII`, which is simply  `X + II`. The number  `27`  is written as  `XXVII`, which is  `XX + V + II`.\n\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not  `IIII`. Instead, the number four is written as  `IV`. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as  `IX`. There are six instances where subtraction is used:\n\n-   `I`  can be placed before  `V`  (5) and  `X`  (10) to make 4 and 9.\n-   `X`  can be placed before  `L`  (50) and  `C`  (100) to make 40 and 90.\n-   `C`  can be placed before  `D`  (500) and  `M`  (1000) to make 400 and 900.\n\nGiven an integer, convert it to a roman numeral.\n\n**Example 1:**\n```js\nInput: num = 3\nOutput: "III"\nExplanation: 3 is represented as 3 ones.\n```\n**Example 2:**\n```js\nInput: num = 58\nOutput: "LVIII"\nExplanation: L = 50, V = 5, III = 3.\n```\n**Example 3:**\n```js\nInput: num = 1994\nOutput: "MCMXCIV"\nExplanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n```\n**Constraints:**\n\n-   `1 <= num <= 3999`	1677615460000	Input: num = 1994\n	# Hint\n1. Take a decimal number as input.  \n2. Check if the number is greater than 1000 or 900 or 500 or 400 or 100 or 90 or 50 or 40 or 10 or 9 or 5 or 4 or 1.  \n3. If it is, then store its equivalent roman number in a array.  \n4. Repeat the step 2-3 with the left over number.	Output: "MCMXCIV"	1669840210405	c	#include <stdio.h>\r\n\r\nchar * intToRoman(int num){\r\n    //Type your solution here\r\n}\r\n\r\nint main(){\r\n    //Type your main here\r\n}
75189bd6-f4c6-487e-b037-d9f145b37313	f5347272-1a3e-43d0-91f1-762d5944c6fb	Task 1: Add Two Numbers	You are given two  **non-empty**  linked lists representing two non-negative integers. The digits are stored in  **reverse order**, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg)\n```js\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\n```\n**Example 2:**\n```js\nInput: l1 = [0], l2 = [0]\nOutput: [0]\n```\n**Example 3:**\n```js\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\n```\n**Constraints:**\n\n-   The number of nodes in each linked list is in the range  `[1, 100]`.\n-   `0 <= Node.val <= 9`\n-   It is guaranteed that the list represents a number that does not have leading zeros.	1677615460000	l1 = [2,4,3]\nl2 = [5,6,4]	## Hint\n\n#### Approach 1: Elementary Math\n\n**Intuition**\n\nKeep track of the carry using a variable and simulate digits-by-digits sum starting from the head of list, which contains the least-significant digit.\n\n![Illustration of Adding two numbers](https://leetcode.com/problems/add-two-numbers/solutions/127833/Figures/2_add_two_numbers.svg)\n\n_Figure 1. Visualization of the addition of two numbers:  $342+465=807342 + 465 = 807342+465=807$.  \nEach node contains a single digit and the digits are stored in reverse order._ \n\n**Algorithm**\n\nJust like how you would sum two numbers on a piece of paper, we begin by summing the least-significant digits, which is the head of  $l1$  and  $l2$. Since each digit is in the range of $ 0…9$, summing two digits may "overflow". For example  $5+7=12$. In this case, we set the current digit to  $2$  and bring over the  $carry=1$  to the next iteration.  $carry$  must be either  $0$  or  $1$ because the largest possible sum of two digits (including the carry) is  $9+9+1=19$.\n\nThe pseudocode is as following:\n\n-   Initialize current node to dummy head of the returning list.\n-   Initialize carry to  $0$.\n-   Loop through lists  $l1$  and  $l2$  until you reach both ends and crarry is  $0$.\n    -   Set  $x$  to node  $l1$'s value. If  $l1$  has reached the end of $l1$, set to  $0$.\n    -   Set  $y$  to node  $l2$'s value. If $l2$  has reached the end of  $l2$, set to  $0$.\n    -   Set  $sum=x+y+carry$.\n    -   Update $carry=sum/10$.\n    -   Create a new node with the digit value of  $(sum\\:mod\\:10)$ and set it to current node's next, then advance current node to next.\n    -   Advance both  $l1$  and $l2$.\n-   Return dummy head's next node.\n\nNote that we use a dummy head to simplify the code. Without a dummy head, you would have to write extra conditional statements to initialize the head's value.\n\nTake extra caution of the following cases:\n| Test case | Explanation |\n|--|--|\n| $l1=[0,1]\\:\\: l2=[0,1,2]$   | When one list is longer than the other. |\n| $l1=[]\\:\\:l2=[0,1]$  | When one list is null, which means an empty list.|\n| $l1=[9,9]\\:\\:l2=[1]$| The sum could have an extra carry of one at the end, which is easy to forget.|\n\n\n**Complexity Analysis**\n\n-   Time complexity :  $O(max⁡(m,n))$. Assume that  mmm  and  nnn  represents the length of $l1$ and  $l2$  respectively, the algorithm above iterates at most  $max⁡(m,n)$ times.\n    \n-   Space complexity :  $O(max⁡(m,n))$. The length of the new list is at most  $max⁡(m,n)+1$.\n    \n\n**Follow up**\n\nWhat if the the digits in the linked list are stored in non-reversed order? For example:\n\n$$(3→4→2)+(4→6→5)=8→0→7$$	[7,0,8]	1669834133405	c	#include <stdio.h>\n#include <stdlib.h>\n\nstruct ListNode {\n    int val;\n    struct ListNode* next;\n};\n\nstruct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) {\n    struct ListNode* currentl1 = l1;\n    struct ListNode* currentl2 = l2;\n    int carry = 0, num3 = 0;\n    struct ListNode* l3;\n    l3 = (struct ListNode*)malloc(sizeof(struct ListNode));\n    struct ListNode* currentl3 = l3;\n    \n    while(currentl1 || currentl2 || carry != 0){\n        int num1 = 0, num2 = 0, num3 = 0;\n        \n        if(currentl1){\n            num1 = currentl1->val;\n            currentl1 = currentl1->next;\n        }\n        \n        if(currentl2){\n            num2 = currentl2->val;\n            currentl2 = currentl2->next;\n        }\n        \n        if(num1 + num2 + carry >= 10){\n            num3 = (num1 + num2 + carry) % 10;\n            carry = 1;\n        } else {\n            \n            num3 = num1 + num2 + carry;\n            carry = 0;\n        }\n        \n        currentl3->val = num3;\n        if(!currentl1 && !currentl2 && carry == 0){\n            currentl3->next = NULL;\n        }else{\n            currentl3->next = (struct ListNode*)malloc(sizeof(struct ListNode));\n            currentl3 = currentl3->next;\n        }\n        \n    }\n    \n    return l3;\n}\n\nint main() {\n    struct ListNode* head1 = NULL;\n    struct ListNode* head2 = NULL;\n    \n    head1 = (struct ListNode*)malloc(sizeof(struct ListNode));\n    head2 = (struct ListNode*)malloc(sizeof(struct ListNode));\n\n\n    head1->val = 1;\n    head1->next = (struct ListNode*)malloc(sizeof(struct ListNode));\n    \n    head1->next->val = 2;\n    head1->next->next = (struct ListNode*)malloc(sizeof(struct ListNode));\n    \n    head1->next->next->val = 3; // assign data to third node\n    head1->next->next->next = NULL;\n    \n    head2->val = 4;\n    head2->next = (struct ListNode*)malloc(sizeof(struct ListNode));\n    \n    head2->next->val = 5;\n    head2->next->next = (struct ListNode*)malloc(sizeof(struct ListNode));\n    \n    head2->next->next->val = 6;\n    head2->next->next->next = NULL;\n    \n    struct ListNode* res = addTwoNumbers(head1, head2);\n    \n    while (res != NULL) {\n        printf(" %d ", res->val);\n        res = res->next;\n    }\n    \n    return 0;\n    \n}
5fb966fd-b48b-44e7-a251-4ef655adb6aa	ae1042cf-7d55-4157-81c6-2690d839609b	Task Rust	Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.	1677591000000	Hello word	Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.	Hello word	1674048788654	rust	fn main() {\r\n    let x: i32 = 5;\r\n    println!("This is Rust, x + 5 = {}", x+5);\r\n}
a8c97a54-a02a-43b4-90f3-a8933b0431cb	f5347272-1a3e-43d0-91f1-762d5944c6fb	Task Python	The provided code stub reads two integers from STDIN,  and . Add code to print three lines where:\n\n1. The first line contains the sum of the two numbers.\n2. The second line contains the difference of the two numbers (first - second).\n3. The third line contains the product of the two numbers.\n\n**Example**\n\n$a = 3$\n\n$b=5$\n\n\nPrint the following:\n\n```\n8\n-2\n15\n```\n\n**Input Format**\n\nThe first line contains the first integer, $a$.\nThe second line contains the second integer, $b$.\n\n**Constraints**\n\n$1 \\leq a \\leq 10^{10}$\n\n$1 \\leq b \\leq 10^{10}$\n\n**Output Format**\n\nPrint the three lines as explained above.\n\n**Sample Input 0**\n\n```\n3\n2\n```\n\nSample Output 0\n\n```\n5\n1\n6\n```\n\nExplanation 0\n\n$$\n3+2 => 5\\\\\n3-2 => 1\\\\\n3*2 => 6\\\\\n$$	1677591780000	Input (stdin)\n3\n2	First, the code stubs read two integers from STDIN:\n\n```\n#Python 2\na = int(raw_input())\nb = int(raw_input())\n\n#Python 3\na = int(input())\nb = int(input())\n```\n\nIn the above statements, `raw_input()` and `input()` are the Python 2 and Python 3 methods to read lines from STDIN. The methods return a string by default. Since this problem uses numeric data, the input value must be converted to an integer. Convert a string to an integer using `int()`.\n\nNow, a bit about Arithmetic Operators\n\nThe three basic arithmetic operators are the following:\n- Addition (+)\n- Subtraction (-)\n- Multiplication (*)\n\nThere are several division methods that will be discussed in the next challenge. Of the three operators shown, multiplication takes precedence over addition and subtraction. Addition and subtraction have equal precedence.\n\nFor example:\n- Given $(3*2)+3 = 6+3=9$, the parentheses are unnecessary due to precedence. Multiplication is performed before addition. This equation can be written more simply as $3*2+3$.\n- To multiply $3$ by $2+3$, write $3*(2+3) = 3*5 = 15$ .	Expected Output\n5\n1\n6	1674049421712	python	if __name__ == '__main__':\r\n    a = int(input())\r\n    b = int(input())\r\n        \r\n    print((a+b),(a-b),(a*b),sep='\\n')
\.


--
-- Data for Name: Submission; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public."Submission" (id, "userId", "taskId", mark, workspace, "isSubmitted", "submittedAt") FROM stdin;
ec5f50a9-d60d-458c-af4f-2b87a02b99d5	fb28399a-dcce-47f0-82cd-fdac5c5d9752	3f565f7c-6115-43a4-a68a-6f42a7c62c62	0	var lengthOfLongestSubstring = function(s) {\r\n    var i=0;\r\n    var MAX=0;\r\n    var temp = new Map();\r\n   \r\n    while(i < s.length){\r\n        \r\n        if(!temp.has(s[i])){\r\n            temp.set(s[i], i);\r\n            var size = temp.size;\r\n            if(size > MAX){\r\n                \r\n                MAX = size;\r\n            }\r\n            i++;\r\n        }else{\r\n            i = temp.get(s[i]) + 1;\r\n            temp = new Map();\r\n        }\r\n    }\r\n    return MAX;\r\n};\r\n\r\n\r\nconsole.log(lengthOfLongestSubstring("abcabcbb"));	t	1669838925221
3c9d93f8-d876-459e-a420-160d2ed80695	fb28399a-dcce-47f0-82cd-fdac5c5d9752	75189bd6-f4c6-487e-b037-d9f145b37313	0	#include <stdio.h>\n#include <stdlib.h>\n\nstruct ListNode {\n    int val;\n    struct ListNode* next;\n};\n\nstruct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) {\n    struct ListNode* currentl1 = l1;\n    struct ListNode* currentl2 = l2;\n    int carry = 0, num3 = 0;\n    struct ListNode* l3;\n    l3 = (struct ListNode*)malloc(sizeof(struct ListNode));\n    struct ListNode* currentl3 = l3;\n    \n    while(currentl1 || currentl2 || carry != 0){\n        int num1 = 0, num2 = 0, num3 = 0;\n        \n        if(currentl1){\n            num1 = currentl1->val;\n            currentl1 = currentl1->next;\n        }\n        \n        if(currentl2){\n            num2 = currentl2->val;\n            currentl2 = currentl2->next;\n        }\n        \n        if(num1 + num2 + carry >= 10){\n            num3 = (num1 + num2 + carry) % 10;\n            carry = 1;\n        } else {\n            \n            num3 = num1 + num2 + carry;\n            carry = 0;\n        }\n        \n        currentl3->val = num3;\n        if(!currentl1 && !currentl2 && carry == 0){\n            currentl3->next = NULL;\n        }else{\n            currentl3->next = (struct ListNode*)malloc(sizeof(struct ListNode));\n            currentl3 = currentl3->next;\n        }\n        \n    }\n    \n    return l3;\n}\n\nint main() {\n    struct ListNode* head1 = NULL;\n    struct ListNode* head2 = NULL;\n    \n    head1 = (struct ListNode*)malloc(sizeof(struct ListNode));\n    head2 = (struct ListNode*)malloc(sizeof(struct ListNode));\n\n\n    head1->val = 1;\n    head1->next = (struct ListNode*)malloc(sizeof(struct ListNode));\n    \n    head1->next->val = 2;\n    head1->next->next = (struct ListNode*)malloc(sizeof(struct ListNode));\n    \n    head1->next->next->val = 3; // assign data to third node\n    head1->next->next->next = NULL;\n    \n    head2->val = 4;\n    head2->next = (struct ListNode*)malloc(sizeof(struct ListNode));\n    \n    head2->next->val = 5;\n    head2->next->next = (struct ListNode*)malloc(sizeof(struct ListNode));\n    \n    head2->next->next->val = 6;\n    head2->next->next->next = NULL;\n    \n    struct ListNode* res = addTwoNumbers(head1, head2);\n    \n    while (res != NULL) {\n        printf(" %d ", res->val);\n        res = res->next;\n    }\n    \n    return 0;\n    \n}	f	1669838997146
13197eed-dee5-4707-958a-2340b501ccd1	fb28399a-dcce-47f0-82cd-fdac5c5d9752	9627e7e4-921d-496c-9b95-286771ceff84	0	#include <stdio.h>\r\n\r\ndouble findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size){\r\n    \r\n    int i=0, j=0, k=0;\r\n    int nums3Size = nums1Size+nums2Size;\r\n    int nums3[nums3Size];\r\n    \r\n    while(i<nums1Size && j<nums2Size){\r\n        if(nums1[i] < nums2[j]){\r\n            nums3[k] = nums1[i];\r\n            i++;\r\n            k++;\r\n        }else if(nums1[i] > nums2[j]){\r\n            nums3[k] = nums2[j];\r\n            j++;\r\n            k++;\r\n        } else {\r\n            nums3[k] = nums2[j];\r\n            j++;\r\n            k++;\r\n        } \r\n    }\r\n    \r\n    while(j<nums2Size){\r\n        nums3[k] = nums2[j];\r\n        j++;\r\n        k++;\r\n    }\r\n    \r\n    while(i<nums1Size){\r\n        nums3[k] = nums1[i];\r\n        i++;\r\n        k++;\r\n    }\r\n        \r\n    if(nums3Size%2 == 0){\r\n        int med1 = nums3[nums3Size/2];\r\n        int med2 = nums3[(nums3Size/2)-1];\r\n        return ((double)(med1+med2)/2);\r\n    }else {\r\n        return (double)(nums3[nums3Size/2]);\r\n    }\r\n}\r\n\r\nint main(){\r\n    \r\n}\r\n\r\n	f	1669839002960
55f7b7e6-4a81-4747-b471-f4568aac97b0	fb28399a-dcce-47f0-82cd-fdac5c5d9752	774664e3-699b-4736-b7de-752a84d4e149	0	#include <stdio.h>\r\n\r\nint* twoSum(int* nums, int numsSize, int target, int* returnSize){\r\n    int *temp;\r\n    temp = (int *) malloc(sizeof(int) * 2);\r\n    for(int i=0; i<numsSize; i++){\r\n        for(int j=i+1; j<numsSize; j++){\r\n            if(nums[i]+nums[j] == target){\r\n                temp[0] = i;\r\n                temp[1] = j;\r\n                \r\n            }\r\n        }\r\n    }\r\n    *returnSize = 2;\r\n    return temp;\r\n    \r\n}\r\n\r\nint main(){\r\n    \r\n}\r\n\r\n	f	1669839014375
\.


--
-- PostgreSQL database dump complete
--

